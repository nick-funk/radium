struct Ray
{
	float3 origin;
	float3 direction;
};

struct Sphere
{
	float3 position;
	float3 color;
	float radius;
};

void SetColor(global char* buffer, int index, char r, char g, char b, char a)
{
	buffer[index] = b;
	buffer[index + 1] = g;
    buffer[index + 2] = r;
    buffer[index + 3] = a;
}

bool IntersectSphere(struct Sphere* s, struct Ray* r, float* t)
{
	float3 rayToCenter = s->position - r->origin;
	float dotProduct = dot(r->direction, rayToCenter);
	float d = dotProduct * dotProduct - dot(rayToCenter, rayToCenter) + s->radius * s->radius;

	if (d < 0)
	{
		return false;
	}

	*t = dotProduct - sqrt(d);

	if (*t < 0)
	{
		*t = dotProduct + sqrt(d);

		if (*t < 0)
		{
			return false;
		}
	}

	return true;
}

float3 ComputeNormal(struct Sphere* s, struct Ray* r, float t)
{
	float3 position = r->origin + (r->direction * t);
	float3 normal = normalize(position - s->position);

	return normal;
}

void GetSpheres(global float* data, struct Sphere* spheres, int count)
{
	int index = 0;
	for (int i = 0; i < count; i++)
	{
		float3 spherePosition = { data[index], data[index + 1], data[index + 2] };
		float radius = data[index + 3];
		float3 color = { data[index + 4], data[index + 5], data[index + 6]};

		spheres[i].position = spherePosition;
		spheres[i].radius = radius;
		spheres[i].color = color;

		index += 7;
	}
}

kernel void raytrace(
	const unsigned int width,
	const unsigned int height,
	const unsigned int sphereCount,
    global char* buffer,
	global float* spheres,
	global float* camera,
	global float* lights)
{
    int xDim = get_global_id(0);
    int yDim = get_global_id(1);
    int index = (4 * width * yDim) + (xDim * 4);

	struct Sphere readSpheres[2];
	GetSpheres(spheres, readSpheres, sphereCount);

	float3 cameraPosition = { camera[0], camera[1], camera[2] };
	float3 cameraDirection = { camera[3], camera[4], camera[5] };

	float dx = 1.0f / (float)(width);
	float dy = 1.0f / (float)(height);
	float aspect = (float)(width) / (float)(height);

	float3 rayOrigin = { (cameraPosition.x + dx * (float)(xDim) - 0.5f) * aspect, cameraPosition.y - dy * (float)(yDim) + 0.5f, cameraPosition.z };

	struct Ray cameraRay;
	cameraRay.origin = rayOrigin;
	cameraRay.direction = cameraDirection;

	float3 lightPosition = { lights[0], lights[1], lights[2] };

	SetColor(buffer, index, 0, 0, 0, 255);

	int intersectIndex = -1;
	float lightAmount = 0;
	float minIntersect = 1000000;
	float3 lightDirection;
	float3 intersectPosition;

	for (int i = 0; i < sphereCount; i++)
	{
		float t = 0;
		bool intersect = IntersectSphere(&readSpheres[i], &cameraRay, &t);

		if (intersect)
		{
			if (t < minIntersect)
			{
				minIntersect = t;
				intersectIndex = i;

				intersectPosition = cameraRay.origin + (cameraRay.direction * t);
				lightDirection = normalize(lightPosition - intersectPosition);

				lightAmount = max(0.0f, dot(ComputeNormal(&readSpheres[i], &cameraRay, t), lightDirection));
			}
		}
	}

	if (intersectIndex > -1)
	{
		struct Ray lightRay;
		lightRay.origin = intersectPosition;
		lightRay.direction = lightDirection;
		bool inShadow = false;

		for (int i = 0; i < sphereCount; i++)
		{
			if (intersectIndex != i)
			{
				float t = 0;
				bool intersect = IntersectSphere(&readSpheres[i], &lightRay, &t);

				if (intersect)
				{
					inShadow = true;
					break;
				}
			}
		}

		if (inShadow)
		{
			lightAmount *= 0.25;
		}

		SetColor(
			buffer, 
			index, 
			0.9 * lightAmount * readSpheres[intersectIndex].color.x + 0.1 * readSpheres[intersectIndex].color.x,
			0.9 * lightAmount * readSpheres[intersectIndex].color.y + 0.1 * readSpheres[intersectIndex].color.y, 
			0.9 * lightAmount * readSpheres[intersectIndex].color.z + 0.1 * readSpheres[intersectIndex].color.z, 
			255);
	}
}