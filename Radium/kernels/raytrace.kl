struct Ray
{
	float3 origin;
	float3 direction;
};

struct Sphere
{
	float3 position;
	float3 color;
	float radius;
};

void SetColor(global char* buffer, int index, char r, char g, char b, char a)
{
	buffer[index] = b;
	buffer[index + 1] = g;
    buffer[index + 2] = r;
    buffer[index + 3] = a;
}

bool IntersectSphere(struct Sphere* s, struct Ray* r, float* t)
{
	float3 rayToCenter = s->position - r->origin;
	float dotProduct = dot(r->direction, rayToCenter);
	float d = dotProduct * dotProduct - dot(rayToCenter, rayToCenter) + s->radius * s->radius;

	if (d < 0)
	{
		return false;
	}

	*t = dotProduct - sqrt(d);

	if (*t < 0)
	{
		*t = dotProduct + sqrt(d);

		if (*t < 0)
		{
			return false;
		}
	}

	return true;
}

float3 ComputeNormal(struct Sphere* s, struct Ray* r, float t)
{
	float3 position = r->origin + (r->direction * t);
	float3 normal = normalize(position - s->position);

	return normal;
}

void GetSpheres(global float* data, struct Sphere* spheres, int count)
{
	int index = 0;
	for (int i = 0; i < count; i++)
	{
		float3 spherePosition = { data[index], data[index + 1], data[index + 2] };
		float radius = data[index + 3];
		float3 color = { data[index + 4], data[index + 5], data[index + 6]};

		spheres[i].position = spherePosition;
		spheres[i].radius = radius;
		spheres[i].color = color;

		index += 7;
	}
}

kernel void raytrace(
	const unsigned int width,
	const unsigned int height,
	const unsigned int sphereCount,
    global char* buffer,
	global float* spheres,
	global float* camera,
	const unsigned int lightCount,
	global float* lights)
{
    int xDim = get_global_id(0);
    int yDim = get_global_id(1);
    int index = (4 * width * yDim) + (xDim * 4);

	struct Sphere readSpheres[2];
	GetSpheres(spheres, readSpheres, sphereCount);

	float3 cameraPosition = { camera[0], camera[1], camera[2] };
	float3 cameraDirection = { camera[3], camera[4], camera[5] };

	float dx = 1.0f / (float)(width);
	float dy = 1.0f / (float)(height);
	float aspect = (float)(width) / (float)(height);

	float3 rayOrigin = { (cameraPosition.x + dx * (float)(xDim) - 0.5f) * aspect, cameraPosition.y - dy * (float)(yDim) + 0.5f, cameraPosition.z };

	struct Ray cameraRay;
	cameraRay.origin = rayOrigin;
	cameraRay.direction = cameraDirection;

	float4 color = (float4)(0, 0, 0, 255);
	float sharedLightCoefficient = 1.0 / lightCount;

	for (int l = 0; l < lightCount * 3; l += 3)
	{
		float3 lightPosition = { lights[l], lights[l + 1], lights[l + 2] };

		int intersectIndex = -1;
		float lightAmount = 0;
		float minIntersect = 1000000;
		float3 lightDirection;
		float3 intersectPosition;

		for (int i = 0; i < sphereCount; i++)
		{
			float t = 0;
			bool intersect = IntersectSphere(&readSpheres[i], &cameraRay, &t);

			if (intersect)
			{
				if (t < minIntersect)
				{
					minIntersect = t;
					intersectIndex = i;

					intersectPosition = cameraRay.origin + (cameraRay.direction * t);
					lightDirection = normalize(lightPosition - intersectPosition);

					lightAmount = max(0.0f, dot(ComputeNormal(&readSpheres[i], &cameraRay, t), lightDirection));
				}
			}
		}

		if (intersectIndex > -1)
		{
			struct Ray lightRay;
			lightRay.origin = intersectPosition;
			lightRay.direction = lightDirection;
			bool inShadow = false;

			for (int i = 0; i < sphereCount; i++)
			{
				if (intersectIndex != i)
				{
					float t = 0;
					bool intersect = IntersectSphere(&readSpheres[i], &lightRay, &t);

					if (intersect)
					{
						inShadow = true;
						break;
					}
				}
			}

			if (inShadow)
			{
				lightAmount *= 0.25;
			}

			color.x += sharedLightCoefficient * (0.9 * lightAmount * readSpheres[intersectIndex].color.x + 0.1 * readSpheres[intersectIndex].color.x);
			color.y += sharedLightCoefficient * (0.9 * lightAmount * readSpheres[intersectIndex].color.y + 0.1 * readSpheres[intersectIndex].color.y);
			color.z += sharedLightCoefficient * (0.9 * lightAmount * readSpheres[intersectIndex].color.z + 0.1 * readSpheres[intersectIndex].color.z);
		}
	}

	SetColor(
		buffer, 
		index, 
		color.x,
		color.y, 
		color.z, 
		color.w);
}